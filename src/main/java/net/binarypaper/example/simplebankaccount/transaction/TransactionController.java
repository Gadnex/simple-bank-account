package net.binarypaper.example.simplebankaccount.transaction;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.annotation.JsonView;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import net.binarypaper.example.simplebankaccount.account.Account;
import net.binarypaper.example.simplebankaccount.account.AccountController;
import net.binarypaper.example.simplebankaccount.account.AccountRepository;
import net.binarypaper.example.simplebankaccount.account.AccountType;

@RestController
@RequestMapping(path = "accounts/{account-id}/transactions", produces = {
        MediaType.APPLICATION_JSON_VALUE })
@CrossOrigin(origins = { "${application.cors.origins}" })
@Tag(name = "Transaction API", description = "Manage bank account transactions")
@RequiredArgsConstructor
public class TransactionController {

    private final AccountController accountController;

    private final AccountRepository accountRepository;

    private final TransactionRepository transactionRepository;

    @Value("${application.credit-card-fee-percentage}")
    private double creditCardFeePercentage;

    @GetMapping
    @JsonView(Transaction.Views.List.class)
    @Operation(summary = "Get a list of all transactions for a bank card", description = "Get a list of all transactions for a bank card")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "List of transactions returned"),
            @ApiResponse(responseCode = "404", description = "Invalid account id and bank card id", content = @Content)
    })
    private List<Transaction> getAllTransactions(
            @PathVariable(name = "account-id") @Parameter(description = "The account id to find", example = "1") Long accountId) {
        // Used to validate if accountId is valid
        accountController.getAccountById(accountId);
        return transactionRepository.findByAccountIdOrderByTransactionDateTimeDesc(accountId);
    }

    @PostMapping("deposit")
    @ResponseStatus(HttpStatus.CREATED)
    @Transactional
    @JsonView(Transaction.Views.View.class)
    @Operation(summary = "Create a new deposit transaction", description = "Create a new deposit transaction. The unique transaction id will be generated by the system.")
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "The deposit transaction was created"),
            @ApiResponse(responseCode = "400", description = "Invalid transaction details", content = @Content)
    })
    public Transaction createDeposit(
            @PathVariable(name = "account-id") @Parameter(description = "The account id to find", example = "1") Long accountId,
            @RequestBody @Validated(Transaction.Views.Deposit.class) @JsonView(Transaction.Views.Deposit.class) Transaction transaction) {
        // Update balance for account
        Account account = accountController.getAccountById(accountId);
        BigDecimal newAccountBalance = account.getBalance().add(transaction.getAmount());
        account.setBalance(newAccountBalance);
        accountRepository.save(account);
        // Create transaction for account
        transaction.setAccount(account);
        transaction.setTransactionType(TransactionType.DEPOSIT);
        transaction.setTransactionDateTime(LocalDateTime.now());
        transactionRepository.save(transaction);
        return transaction;
    }

    @PostMapping("withdrawal")
    @ResponseStatus(HttpStatus.CREATED)
    @Transactional
    @JsonView(Transaction.Views.View.class)
    @Operation(summary = "Create a new withdrawal transaction", description = "Create a new withdrawal transaction. The unique transaction id will be generated by the system.")
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "The withdrawal transaction was created"),
            @ApiResponse(responseCode = "400", description = "Invalid transaction details", content = @Content)
    })
    public Transaction createWithdrawal(
            @PathVariable(name = "account-id") @Parameter(description = "The account id to find", example = "1") Long accountId,
            @RequestBody @Validated(Transaction.Views.Withdrawal.class) @JsonView(Transaction.Views.Withdrawal.class) Transaction transaction) {
        // Update balance for account
        Account account = accountController.getAccountById(accountId);
        BigDecimal newAccountBalance = account.getBalance().subtract(transaction.getAmount());
        if (newAccountBalance.compareTo(BigDecimal.ZERO) < 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "There are insufficient funds to make the withdrawal");
        }
        account.setBalance(newAccountBalance);
        accountRepository.save(account);
        // Create transaction for account
        transaction.setAccount(account);
        transaction.setTransactionType(TransactionType.WITHDRAWAL);
        transaction.setTransactionDateTime(LocalDateTime.now());
        transaction.setAmount(transaction.getAmount().negate());
        transactionRepository.save(transaction);
        return transaction;
    }

    @PostMapping("transfer")
    @ResponseStatus(HttpStatus.CREATED)
    @Transactional
    @JsonView(Transaction.Views.View.class)
    @Operation(summary = "Create a new transfer transaction", description = "Create a new transfer transaction. The unique transaction id will be generated by the system.")
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "The transfer transaction was created"),
            @ApiResponse(responseCode = "400", description = "Invalid transaction details", content = @Content)
    })
    public Transaction createTransfer(
            @PathVariable(name = "account-id") @Parameter(description = "The account id to find", example = "1") Long accountId,
            @RequestBody @Validated(Transaction.Views.Transfer.class) @JsonView(Transaction.Views.Transfer.class) Transaction transaction) {
        BigDecimal transactionAmount = transaction.getAmount();
        BigDecimal feesAmount = BigDecimal.ZERO;
        Account account = accountController.getAccountById(accountId);
        // Calculate credit card fees
        if (account.getAccountType().equals(AccountType.CREDIT_CARD)) {
            feesAmount = transactionAmount
                    .multiply(BigDecimal.valueOf(creditCardFeePercentage).divide(BigDecimal.valueOf(100L)))
                    .setScale(2, RoundingMode.HALF_UP);
        }
        // Update balance for account
        BigDecimal accountBalance = account.getBalance();
        BigDecimal newAccountBalance = accountBalance.subtract(transactionAmount).subtract(feesAmount);
        if (newAccountBalance.compareTo(BigDecimal.ZERO) < 0) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "There are insufficient funds to make the transfer");
        }
        account.setBalance(newAccountBalance);
        accountRepository.save(account);
        // Create transaction for account
        transaction.setAccount(account);
        transaction.setTransactionType(TransactionType.TRANSFER);
        transaction.setAmount(transactionAmount.negate());
        transaction.setTransactionDateTime(LocalDateTime.now());
        transactionRepository.save(transaction);
        // Create fees transaction for credit card payments
        if (account.getAccountType().equals(AccountType.CREDIT_CARD)) {
            Transaction feesTransaction = new Transaction();
            feesTransaction.setAccount(account);
            feesTransaction.setAmount(feesAmount);
            feesTransaction.setDescription("Fees for credit card payment");
            feesTransaction.setTransactionDateTime(transaction.getTransactionDateTime());
            feesTransaction.setTransactionType(TransactionType.FEES);
            transactionRepository.save(feesTransaction);
        }
        // Update balance for destination account
        Account destinationAccount = accountController
                .getAccountByNumber(transaction.getDestinationBankAccountNumber());
        destinationAccount.setBalance(destinationAccount.getBalance().add(transactionAmount));
        accountRepository.save(destinationAccount);
        // Create transaction for destination account
        Transaction destinationAccountTransaction = new Transaction();
        destinationAccountTransaction.setAccount(destinationAccount);
        destinationAccountTransaction.setDescription("Payment from " + account.getHolderName());
        destinationAccountTransaction.setTransactionType(TransactionType.TRANSFER);
        destinationAccountTransaction.setAmount(transactionAmount);
        destinationAccountTransaction.setTransactionDateTime(transaction.getTransactionDateTime());
        transactionRepository.save(destinationAccountTransaction);
        return transaction;
    }

}